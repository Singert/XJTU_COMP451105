子文件夹：./core
子文件夹：./core/dfa
文件：./core/dfa/dfa.go
内容：
package dfa

import (
	"fmt"
	"lab2/core/utils"
	"os"
)

func (d *DFA) buildAcceptMap() {
	d.acceptMap = make(map[string]bool)
	for _, s := range d.AcceptStates {
		d.acceptMap[s] = true
	}
}

func (d *DFA) ExportDFAtoDot(filename string) error {
	file, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer file.Close()

	fmt.Fprintln(file, "digraph DFA {")
	fmt.Fprintln(file, "  rankdir=LR;")

	// 初始状态箭头（空节点到起始状态）
	fmt.Fprintf(file, `  "" -> %s;`+"\n", d.StartState)

	// 输出所有状态节点
	for _, s := range d.States {
		shape := "circle"
		if d.acceptMap[s] {
			shape = "doublecircle"
		}
		fmt.Fprintf(file, `  %s [shape=%s];`+"\n", s, shape)
	}

	// 输出转移边
	for from, transitions := range d.Transitions {
		for symbol, to := range transitions {
			fmt.Fprintf(file, `  %s -> %s [label="%s"];`+"\n", from, to, symbol)
		}
	}

	fmt.Fprintln(file, "}")
	return nil
}

func (d *DFA) MatchDFA(input string, verbose bool) (bool, []TransitionTrace) {
	currentState := d.StartState
	trace := []TransitionTrace{}
	for i, ch := range input {
		symbol := string(ch)
		if !utils.Contains(d.Alphabet, symbol) {
			if verbose {
				fmt.Printf("Step %d: %s --%s--> ❌invalid symbol\n", i+1, currentState, symbol)
			}
			return false, nil
		}
		nextState, ok := d.Transitions[currentState][symbol]
		if !ok {
			if verbose {
				fmt.Printf("Step %d: %s --%s--> ❌invalid transition\n", i+1, currentState, symbol)
			}
			return false, nil
		}

		trace = append(trace, TransitionTrace{
			From:   currentState,
			Symbol: symbol,
			To:     nextState,
		})

		if verbose {
			fmt.Printf("Step %d: %s --%s--> %s\n", i+1, currentState, symbol, nextState)
		}
		currentState = nextState
	}
	return d.acceptMap[currentState], trace
}

func (d *DFA) EnumValidStrings(maxLength int) []string {
	var validStrings []string
	var currentString string
	var currentState string

	// BFS queue
	queue := make([]struct {
		state  string
		string string
		length int
	}, 0)

	// Start with the initial state and an empty string
	queue = append(queue, struct {
		state  string
		string string
		length int
	}{d.StartState, "", 0})

	for len(queue) > 0 {
		item := queue[0]
		queue = queue[1:]

		currentState = item.state
		currentString = item.string

		if item.length > maxLength {
			continue
		}

		if d.acceptMap[currentState] && item.length <= maxLength {
			validStrings = append(validStrings, currentString)
		}

		for _, symbol := range d.Alphabet {
			nextState, ok := d.Transitions[currentState][symbol]
			if ok {
				queue = append(queue, struct {
					state  string
					string string
					length int
				}{nextState, currentString + symbol, item.length + 1})
			}
		}
	}
	return validStrings
}

func (d *DFA) CheckValidity() bool {
	fmt.Printf("[Checking DFA Validity]\n")

	// 1️⃣ check start_state not nil
	fmt.Printf("checking start_state not nil: ")
	if d.StartState == "" {
		fmt.Print("❌ Start state is nil\n")
		fmt.Println("[DFA Invalid]")
		return false
	} else {
		fmt.Println("PASS")
	}

	// 2️⃣ check start_state in states
	fmt.Print("checking start_state in states: ")
	if !utils.Contains(d.States, d.StartState) {
		fmt.Printf("❌ Start state %s not in states\n", d.StartState)
		fmt.Println("[DFA Invalid]")
		return false
	} else {
		fmt.Println("PASS")
	}

	// 3️⃣ check accept_states not nil
	fmt.Print("checking accept_states not nil: ")
	if len(d.AcceptStates) == 0 {
		fmt.Print("❌ Accept states is nil\n")
		fmt.Println("[DFA Invalid]")
		return false
	} else {
		fmt.Println("PASS")
	}

	// 4️⃣ check accept_states in states
	fmt.Print("checking accept_states in states: ")
	for _, s := range d.AcceptStates {
		if !utils.Contains(d.States, s) {
			fmt.Printf("❌ Accept state %s not in states\n", s)
			fmt.Println("[DFA Invalid]")
			return false
		}
	}
	fmt.Println("PASS")

	// 5️⃣ check transitions not nil
	fmt.Print("checking transitions not nil: ")
	if len(d.Transitions) == 0 {
		fmt.Print("❌ Transitions is nil\n")
		fmt.Println("[DFA Invalid]")
		return false
	} else {
		fmt.Println("PASS")
	}

	// 6️⃣ check all transitions refer to valid states and symbols
	fmt.Print("checking transitions for valid states and symbols: ")
	for from, trans := range d.Transitions {
		if !utils.Contains(d.States, from) {
			fmt.Printf("❌ Transition state %s not in states\n", from)
			fmt.Println("[DFA Invalid]")
			return false
		}
		for symbol, to := range trans {
			if !utils.Contains(d.Alphabet, symbol) {
				fmt.Printf("❌ Transition symbol %s not in alphabet\n", symbol)
				fmt.Println("[DFA Invalid]")
				return false
			}
			if !utils.Contains(d.States, to) {
				fmt.Printf("❌ Transition destination %s not in states\n", to)
				fmt.Println("[DFA Invalid]")
				return false
			}
		}
	}
	fmt.Println("PASS")
	for _, s := range d.States {
		for _, sym := range d.Alphabet {
			if _, ok := d.Transitions[s][sym]; !ok {
				fmt.Printf("[CheckValidity] Warning: State '%s' missing transition on symbol '%s'\n", s, sym)
			}
		}
	}
	fmt.Println("[DFA Valid]")
	return true
}

func (d *DFA) ExportToDot(filename string, trace []TransitionTrace) error {
	file, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer file.Close()

	fmt.Fprintln(file, "digraph DFA {")
	fmt.Fprintln(file, "  rankdir=LR;")
	fmt.Fprintln(file, `  "" -> `+d.StartState+`;`)

	// accept states double circle
	for _, s := range d.States {
		shape := "circle"
		if d.acceptMap[s] {
			shape = "doublecircle"
		}
		fmt.Fprintf(file, "  %s [shape=%s];\n", s, shape)
	}

	// mark all matched paths with highlight color
	edgeMark := make(map[string]bool)
	for _, t := range trace {
		key := fmt.Sprintf("%s_%s_%s", t.From, t.Symbol, t.To)
		edgeMark[key] = true
	}

	// transition-edges
	for from, trans := range d.Transitions {
		for symbol, to := range trans {
			key := fmt.Sprintf("%s_%s_%s", from, symbol, to)
			if edgeMark[key] {
				fmt.Fprintf(file, `  %s -> %s [label=%s, color=red, penwidth=4];`+"\n", from, to, symbol)
			} else {
				fmt.Fprintf(file, `  %s -> %s [label=%s];`+"\n", from, to, symbol)
			}
		}
	}
	fmt.Fprintf(file, "}")
	return nil
}

/*
TODO:
[] 这个 DFA 的状态过程生成 图形可视化（如 Graphviz .dot 文件
[] “合法性检查”和“所有长度 ≤ N 的合法字符串输出”
添加合法性检查（是否所有状态符号转移完备）

枚举所有规则串（长度 ≤ N）：使用 BFS 枚举输入串并判断是否被接受
重构为模块化包（方便后续实验复用）
将 dfa.Match() 改成可输出状态轨迹
*/

文件：./core/dfa/dfa_model.go
内容：
package dfa

type DFA struct {
	Alphabet     []string                     `json:"alphabet"`
	States       []string                     `json:"states"`
	StartState   string                       `json:"start_state"`
	AcceptStates []string                     `json:"accept_states"`
	Transitions  map[string]map[string]string `json:"transitions"`

	//运行时变量
	acceptMap map[string]bool
}

type TokenType string

const (
	TokenID    TokenType = "ID"  // Identifier
	TokenNUM   TokenType = "NUM" // Number
	TokenFLO   TokenType = "FLO"
	TokenOP    TokenType = "OP"
	TokenDELIM TokenType = "DELIM"
	TokenKW    TokenType = "KEYWORD"
	TokenERROR TokenType = "ERROR"
	TokenWithespace TokenType = "WHITESPACE"
)

type Token struct {
	Type   TokenType
	Lexeme string
}


type DFAWithTokenType struct{
	TokenType TokenType `json:"token_type"`
	DFA *DFA `json:"dfa"`
}

type TransitionTrace struct {
	From   string
	Symbol string
	To     string
}
文件：./core/dfa/load_dfa.go
内容：
package dfa

import (
	"encoding/json"
	"fmt"
	"os"
)

func LoadDFAFromJson(fileName string) (*DFA, error) {
	data, err := os.ReadFile(fileName)
	if err != nil {
		return nil, err
	}
	var dfa DFA
	err = json.Unmarshal(data, &dfa)
	if err != nil {
		return nil, err
	}
	dfa.CheckValidity()
	dfa.buildAcceptMap()
	dfa.ExportDFAtoDot("./dot/dfa.dot")
	return &dfa, nil
}

func LoadMultiDFAFromJson(fileName string, dotPath string) (*[]DFAWithTokenType, error) {
	data, err := os.ReadFile(fileName)
	if err != nil {
		return nil, err
	}
	var dfas []DFAWithTokenType
	err = json.Unmarshal(data, &dfas)
	if err != nil {
		return nil, err
	}
	for i := range dfas {
		fmt.Printf("Loaded DFA from %s, q0 transitions: %+v\n", fileName, dfas[i].DFA.Transitions["q0"])
		dfas[i].DFA.CheckValidity()
		dfas[i].DFA.buildAcceptMap()
		dotPath := dotPath + "/" + string(dfas[i].TokenType) + ".dot"
		dfas[i].DFA.ExportDFAtoDot(dotPath)
	}
	return &dfas, nil
}

文件：./core/dfa_test.go
内容：
package core_test

import (
	"fmt"
	"lab2/core/dfa"
	"os"
	"testing"
)

func TestDFA(t *testing.T) {
	dfaWithTokenType, err := dfa.LoadMultiDFAFromJson("../json/all_dfa.json", "./dot/test")
	if err != nil {
		fmt.Println("Error loading DFA:", err)
		os.Exit(1)
	}

	for _, entry := range *dfaWithTokenType {
		fmt.Printf("\nTesting DFA for token type: %s\n", entry.TokenType)
		fmt.Printf("Alphabet: %v\n", entry.DFA.Alphabet)

		// 测试单字符匹配
		for _, symbol := range entry.DFA.Alphabet {
			ok, _ := entry.DFA.MatchDFA(symbol,true)
			fmt.Printf("Single symbol '%s': matched=%v\n", symbol, ok)
		}

		// 测试复杂词素，针对不同token类型
		testWords := []string{}
		switch entry.TokenType {
		case dfa.TokenID:
			testWords = []string{"int", "x", "var1", "_temp"}
		case dfa.TokenNUM:
			testWords = []string{"0", "123", "4567"}
		case dfa.TokenFLO:
			testWords = []string{"3.1e5", "0.123", ".5", "1e10", "6.022E23"}
		case dfa.TokenOP:
			testWords = []string{"=", "==", "+", "+=", "!"}
		case dfa.TokenDELIM:
			testWords = []string{"(", ")", "{", "}", ";", ","}
		}

		for _, w := range testWords {
			ok, trace := entry.DFA.MatchDFA(w,true)
			fmt.Printf("Word '%s': matched=%v\n", w, ok)
			for _, step := range trace {
				fmt.Printf("  %s --%s--> %s\n", step.From, step.Symbol, step.To)
			}
		}
	}
}

文件：./core/scanner.go
内容：
package core

import (
	"lab2/core/dfa"
	"unicode"
)

type Scanner struct {
	DFAList []struct {
		DFA       *dfa.DFA
		TokenType dfa.TokenType
	}
}

func NewScanner() *Scanner {
	return &Scanner{}
}

func (s *Scanner) RegisterDFA(d *dfa.DFA, t dfa.TokenType) {
	s.DFAList = append(s.DFAList, struct {
		DFA       *dfa.DFA
		TokenType dfa.TokenType
	}{DFA: d, TokenType: t})
}

func isWhitespace(r rune) bool {
	return unicode.IsSpace(r)
}

func (s *Scanner) Scan(input string) (matched dfa.Token, length int) {
	if len(input) == 0 {
		return dfa.Token{Type: dfa.TokenERROR, Lexeme: ""}, 0
	}

	runes := []rune(input)
	if unicode.IsSpace(runes[0]) {
		i := 1
		for i < len(runes) && unicode.IsSpace(runes[i]) {
			i++
		}
		return dfa.Token{Type: dfa.TokenWithespace, Lexeme: string(runes[:i])}, i
	}

	maxLen := 0
	var maxToken dfa.Token
	var maxDFA *dfa.DFA

	for _, entry := range s.DFAList {
		for i := 1; i <= len(runes); i++ {
			sub := string(runes[:i])
			ok, _ := entry.DFA.MatchDFA(sub, false)
			if ok && i > maxLen {
				maxLen = i
				maxToken = dfa.Token{Type: entry.TokenType, Lexeme: sub}
				maxDFA = entry.DFA
			}
		}
	}

	if maxLen == 0 {
		return dfa.Token{Type: dfa.TokenERROR, Lexeme: string(runes[0])}, 1
	}
	_, _ = maxDFA.MatchDFA(maxToken.Lexeme, true)
	return maxToken, maxLen
}

// func (s *Scanner) Scan(input string) (matched dfa.Token, length int) {
// 	fmt.Printf("[Scan] input segment: '%s'\n", input)

// 	maxLen := 0
// 	var maxToken dfa.Token

// 	// 从输入的第一个字符开始尝试匹配
// 	for _, entry := range s.DFAList {
// 		// 这里我们尝试从字符长度为 1 到最大长度进行匹配
// 		for i := 1; i <= len(input); i++ {
// 			sub := input[:i] // 获取从开头到第i个字符的子字符串
// 			ok, _ := entry.DFA.MatchDFA(sub)
// 			fmt.Printf("[Scan] trying DFA token %s on input '%s'\n", entry.TokenType, sub)

// 			if ok {
// 				if i > maxLen { // 如果当前匹配的长度大于之前的最大匹配长度，更新 maxToken
// 					maxLen = i
// 					maxToken = dfa.Token{Type: entry.TokenType, Lexeme: sub}
// 				}
// 			}
// 		}
// 	}

// 	// 如果没有匹配，检查是否为空白符或者错误字符
// 	if maxLen == 0 {
// 		runes := []rune(input)
// 		if len(runes) > 0 && isWhitespace(runes[0]) {
// 			return dfa.Token{Type: dfa.TokenWithespace, Lexeme: string(runes[0])}, 1
// 		}
// 		return dfa.Token{Type: dfa.TokenERROR, Lexeme: string(input[0])}, 1
// 	}

// 	return maxToken, maxLen
// }

子文件夹：./core/utils
文件：./core/utils/utils.go
内容：
package utils


// util function to check if a string exists in a slice
func Contains(slice []string, item string) bool {
	for _, s := range slice {
		if s == item {
			return true
		}
	}
	return false
}


文件：./go.mod
内容：
module lab2

go 1.23.2


文件：./main.go
内容：
package main

import (
	"bufio"
	"flag"
	"fmt"
	"lab2/core"
	"lab2/core/dfa"
	"os"
	_ "os/exec"
	"strings"
)

func main() {
	// define command line arguments
	dotPath := flag.String("d", "./dot", "Path to save dot file")
	flag.StringVar(dotPath, "dot", "./dot", "Path to save dot file")
	flag.Parse()

	dfaWithTokenType, err := dfa.LoadMultiDFAFromJson("./json/all_dfa.json", *dotPath)
	if err != nil {
		fmt.Println("Error loading DFA:", err)
		os.Exit(1)
	}

	scanner := core.NewScanner()
	for i := range *dfaWithTokenType {
		scanner.RegisterDFA((*dfaWithTokenType)[i].DFA, (*dfaWithTokenType)[i].TokenType)
	}

	var reader = bufio.NewReader(os.Stdin)

	for {

		fmt.Print("Enter a string to match (or 'quit' to quit): ")
		line, err := reader.ReadString('\n')
		if err != nil {
			fmt.Println("Error reading input:", err)
			continue
		}
		line = strings.TrimSpace(line)

		if line == "quit" {
			break
		}
		// Matched, trace := dfa.MatchDFA(input)
		// if Matched {
		// 	fmt.Println("✅ Accepted")
		// 	dotName = *dotPath + "/" + input + ".dot"
		// 	dfa.ExportToDot(dotName, trace)

		// } else {
		// 	fmt.Println("❌ Not Accepted")
		// }

		// pos := 0
		// for pos < len(input) {
		// 	token, length := scanner.Scan(input[pos:])
		// 	if token.Type == dfa.TokenWithespace {
		// 		pos += length
		// 		fmt.Printf("[main:when token with space]Skip %d whitespace\n", length)
		// 		continue
		// 	}
		// 	if token.Type == dfa.TokenERROR {
		// 		fmt.Printf("❌ Error: invalid token '%s' at position %d\n", token.Lexeme, pos)
		// 		pos += length
		// 		continue
		// 	}

		// 	fmt.Printf("[Token]: <%s>, [Lexeme]: '%s'\n", token.Type, token.Lexeme)
		// 	// 可选：导出匹配的 dot 文件，示例用第一个 DFA (你可扩展对应匹配 DFA)
		// 	_, trace := scanner.DFAList[0].DFA.MatchDFA(token.Lexeme,false)
		// 	dotName := fmt.Sprintf("%s/%s_%d.dot", *dotPath, token.Lexeme, pos)
		// 	err := scanner.DFAList[0].DFA.ExportToDot(dotName, trace)
		// 	if err != nil {
		// 		fmt.Println("Export dot failed:", err)
		// 	}

		// 	pos += length
		// }
		pos := 0
		inputRunes := []rune(line)
		length := len(inputRunes)

		for pos < length {
			fmt.Printf("[DEBUG] pos=%d, next char='%c'\n", pos, inputRunes[pos])

			subInput := string(inputRunes[pos:])
			token, tokenLen := scanner.Scan(subInput)
			fmt.Printf("[DEBUG] token='%s', length=%d\n", token.Lexeme, tokenLen)

			if tokenLen == 0 {
				pos++ // 防止死循环
				continue
			}

			if token.Type == dfa.TokenWithespace {
				pos += tokenLen
				fmt.Printf("[main] Skip %d whitespace characters\n", tokenLen)
				continue
			}

			if token.Type == dfa.TokenERROR {
				fmt.Printf("❌ Error: invalid token '%s' at position %d\n", token.Lexeme, pos)
				pos += tokenLen
				continue
			}

			fmt.Printf("[Token]: <%s>, [Lexeme]: '%s'\n", token.Type, token.Lexeme)
			_, trace := scanner.DFAList[0].DFA.MatchDFA(token.Lexeme, false)
			dotName := fmt.Sprintf("%s/%s_%d.dot", *dotPath, token.Lexeme, pos)
			err := scanner.DFAList[0].DFA.ExportToDot(dotName, trace)
			if err != nil {
				fmt.Println("Export dot failed:", err)
			}

			pos += tokenLen
		}

	}
}

文件：./output.txt
内容：

文件：./README.md
内容：

- [x] 添加合法性检查（是否所有状态符号转移完备）

- [x] 枚举所有规则串（长度 ≤ N）：使用 BFS 枚举输入串并判断是否被接受

- [x] 将 dfa.Match() 改成可输出状态轨迹

- [x] dot可视化DFA以及状态转移过程


