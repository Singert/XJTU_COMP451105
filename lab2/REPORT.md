
网安2201 常兆鑫 2226114409

---

# 实验二报告：基于多DFA的词法分析器设计与实现

## 一、实验目的

* 设计并实现多个DFA，分别识别不同类别的词法单元（Token），如标识符、数字、浮点数、运算符、分隔符等。
* 设计通用的DFA加载、合法性检查、匹配和可视化模块。
* 实现基于多个DFA的最长匹配扫描器（Scanner），实现对输入代码的完整词法分析。
* 支持对匹配过程的状态转移轨迹可视化（Graphviz DOT格式），便于调试与教学。
* 实现关键字识别，将标识符中关键字区分出来。
* 支持从文件或交互式终端输入代码，输出词法分析结果到终端或文件。

## 二、功能概述与实现方法

### 1. 多DFA定义与管理

* 设计多个JSON格式的DFA定义文件（如`all_dfa.json`），包含每个Token类型的字母表、状态集、起始状态、接受状态及转移函数。
* 每个DFA封装成`DFA`结构体，包含运行时辅助数据`acceptMap`以快速判定接受状态。
* 通过`LoadMultiDFAFromJson`统一加载所有DFA，自动进行合法性检查（包括起始状态、接受状态完整性和转移完备性），打印缺失转移的警告，提升健壮性。

### 2. DFA匹配与轨迹输出

* `MatchDFA`函数实现输入串在DFA上的匹配，支持verbose模式打印每一步状态转移。
* 同时返回匹配是否成功及状态转移轨迹列表，供可视化模块使用。
* 轨迹通过`ExportToDot`生成Graphviz `.dot`文件，接受状态以双圈标识，匹配路径高亮。

### 3. Scanner模块：最长匹配词法分析

* `Scanner`结构体维护多个DFA及其对应Token类型。
* 扫描时针对输入剩余部分，尝试每个DFA最长匹配，选出最大匹配长度及对应Token。
* 支持空白字符批量识别及跳过，错误字符识别并报告。
* 实现关键字识别功能，自动将标识符中的关键字转换成关键字Token类型。
* 封装扫描结果输出逻辑，支持输出至终端和文件。
* 提供`ScanAndOutput`函数实现完整输入字符串的词法分析及结果打印与DOT文件生成。

### 4. 主程序与交互

* 支持命令行参数指定DFA DOT文件输出路径、是否开启verbose、源代码输入文件路径、词法分析结果输出文件路径。
* 支持从指定文件或交互终端读入待分析代码。
* 调用Scanner进行词法分析，输出token序列及状态转移图。
* 交互模式下支持逐行输入，方便调试与演示。

### 5. 测试模块

* `core/dfa_test.go`针对DFA加载、合法性检查、单字符和复杂词素匹配进行了详尽测试，覆盖不同Token类型。
* `core/scanner_test.go`设计了多种输入用例（包含关键字、运算符、空白符、错误字符），验证Scanner的正确性和完整性。
* 测试覆盖输入边界条件和典型场景，保证系统稳定。

## 三、模块功能详述与调用关系

| 模块路径                   | 主要职责                                 | 依赖关系                          |
| ---------------------- | ------------------------------------ | ----------------------------- |
| `core/dfa`             | DFA定义、加载、合法性检查、匹配、状态轨迹及DOT输出         | 依赖`core/utils`中的字符串工具         |
| `core/utils`           | 通用工具函数（如字符串包含检查）                     | 无                             |
| `core/scanner`         | 管理多个DFA，完成最长匹配扫描，实现关键字识别及结果输出        | 依赖`core/dfa`模块                |
| `main.go`              | 程序入口，解析命令行参数，加载DFA，初始化Scanner，处理输入输出 | 依赖`core/dfa`、`core/scanner`模块 |
| `json/*.json`          | 各种Token类型的DFA定义文件                    | -                             |
| `core/dfa_test.go`     | DFA模块单元测试                            | 依赖`core/dfa`模块                |
| `core/scanner_test.go` | Scanner模块单元测试                        | 依赖`core/scanner`和`core/dfa`模块 |

* **调用流程**：

  * `main.go`启动时，调用`dfa.LoadMultiDFAFromJson`加载所有DFA，并对其合法性进行检查。
  * 创建`scanner.Scanner`实例，注册所有DFA。
  * 根据输入源（文件或终端），调用`scanner.ScanAndOutput`执行词法分析，输出token序列与DOT文件。
  * DOT文件可以用Graphviz工具渲染，帮助理解DFA匹配过程。
  * 测试模块通过Go测试框架执行，验证整体功能正确性。

## 四、实验总结

本实验完成了基于多个DFA的词法分析器设计，涵盖了DFA的定义、验证、匹配及轨迹输出功能，实现了最长匹配策略的Scanner，支持关键字识别和错误处理。通过DOT文件生成可视化，便于调试与教学。整体结构模块化，接口清晰，方便后续扩展与维护。测试覆盖充分，验证了词法分析器的正确性和健壮性。

---



# 五、图表与流程示意

### 1. 系统整体模块结构图

```
+-----------------+      +-----------------+      +------------------+
|                 |      |                 |      |                  |
|    main.go      +----->|   Scanner       +----->|  Multiple DFA     |
|  (入口与IO处理) |      | (最长匹配扫描器) |      | (不同Token的DFA)  |
|                 |      |                 |      |                  |
+-----------------+      +-----------------+      +------------------+
                                       |
                                       v
                              +------------------+
                              |   utils 包       |
                              |(通用辅助工具函数) |
                              +------------------+
```

**说明**：

* `main.go`负责命令行参数处理、文件/终端IO和整体流程控制。
* `Scanner`整合多个DFA，实现最长匹配扫描及关键字识别。
* 每个`DFA`独立定义特定Token的状态机，支持匹配与轨迹输出。
* `utils`模块提供基础函数如字符串查找等辅助功能。

---

### 2. DFA匹配流程图

```
+-------------------+
| 输入字符串 S       |
+-------------------+
          |
          v
+-------------------+
| 初始化当前状态 q0   |
+-------------------+
          |
          v
+-------------------+
| 读取下一个字符 c    |
+-------------------+
          |
          v
+-------------------+
| c 是否在字母表中？  |--否--> 输出错误，无匹配，结束
+-------------------+
          |
         是
          |
          v
+-------------------------+
| q_next = 转移(q_current, c) |
+-------------------------+
          |
          v
+-------------------+
| q_next 存在？      |--否--> 输出错误，无匹配，结束
+-------------------+
          |
         是
          |
          v
+-------------------+
| 更新状态 q_current = q_next |
+-------------------+
          |
          v
+-------------------+
| 是否还有字符？     |--是--> 回到读取下一个字符
+-------------------+
          |
         否
          |
          v
+-------------------+
| q_current 是否为接受状态？ |
+-------------------+
          |
         是/否
          |
          v
+-------------------+
| 输出匹配成功或失败  |
+-------------------+
```

---

### 3. Scanner最长匹配流程图

```
+---------------------+
| 输入剩余字符串段 S   |
+---------------------+
            |
            v
+---------------------+
| 对每个DFA进行尝试匹配  |
+---------------------+
            |
            v
+---------------------+
| 找到最长匹配长度 L 和对应Token |
+---------------------+
            |
            v
+---------------------+
| L == 0？            |--是--> 识别错误Token
+---------------------+
            | 否
            v
+---------------------+
| 返回最长匹配Token及长度  |
+---------------------+
            |
            v
+---------------------+
| 扫描剩余字符串，循环处理 |
+---------------------+
```

---

### 4. 词法分析处理流程

```
+----------------------------+
| 读取输入源（文件或终端）     |
+----------------------------+
               |
               v
+----------------------------+
| 调用Scanner进行词法分析       |
+----------------------------+
               |
               v
+----------------------------+
| 识别Token序列，处理空白与错误 |
+----------------------------+
               |
               v
+----------------------------+
| 输出Token及匹配轨迹（终端/文件）|
+----------------------------+
               |
               v
+----------------------------+
| 生成对应Token的DFA DOT图     |
+----------------------------+
```

---

### 5. DFA状态转移图示意（示例）

```
digraph DFA {
  rankdir=LR;
  "" -> q0;
  q0 [shape=circle];
  q1 [shape=doublecircle];
  q0 -> q1 [label="a"];
  q1 -> q1 [label="a,b"];
}
```

* 圆圈表示状态，双圈表示接受状态。
* 边上的标签表示输入符号。
* 图中路径红色高亮表示匹配过程中经过的路径。

