æ–‡ä»¶ï¼š./design.md
å†…å®¹ï¼š
å¾ˆå¥½ï¼Œç›®å‰é¡¹ç›®å·²ç»æœ‰äº†åŸºç¡€çš„è¯æ³•åˆ†æå’Œç¡¬ç¼–ç çš„æ§åˆ¶ç»“æ„ç”Ÿæˆå‡½æ•°ã€‚ä¸ºäº†é€æ­¥å®ç°æ”¯æŒä½ åˆ—å‡ºçš„å…¨éƒ¨è¯­å¥äº§ç”Ÿå¼ï¼Œæˆ‘ä»¬å¯ä»¥æŒ‰å¦‚ä¸‹å‡ ä¸ªé˜¶æ®µæ¨è¿›ï¼š

---

## âœ… é˜¶æ®µæ€§ç›®æ ‡ä¸æ¨èé¡ºåº

### **ç¬¬ä¸€é˜¶æ®µï¼šåŸºç¡€è¯­å¥æ”¯æŒ**

å®ç°æ‰€æœ‰ç®€å• `S â†’ ...` ç±»å‹è¯­å¥çš„ä¸­é—´ä»£ç ç”Ÿæˆï¼š

| è¯­å¥ç±»å‹           | çŠ¶æ€   | ä¸‹ä¸€æ­¥å»ºè®®             |
| -------------- | ---- | ----------------- |
| `S â†’ d = E`    | âŒæœªå®ç° | âœ… å®ç°èµ‹å€¼è§£æä¸è¡¨è¾¾å¼è®¡ç®—ç”Ÿæˆ  |
| `S â†’ return E` | âŒæœªå®ç° | âœ… å®ç° return è¡¨è¾¾å¼è®¡ç®— |
| `S â†’ d(Å˜)`     | âŒæœªå®ç° | âœ… æ”¯æŒå‡½æ•°è°ƒç”¨çš„å‚æ•°ä¸è°ƒç”¨ç”Ÿæˆ  |
| `S â†’ d[Äš] = E` | âœ…ç¡¬ç¼–ç  | ğŸ” æ”¹ä¸ºè§£æå¼è¾“å…¥        |

> å»ºè®®ä¸‹ä¸€æ­¥ä¼˜å…ˆå®Œæˆï¼š**èµ‹å€¼è¯­å¥ã€return è¯­å¥ã€å‡½æ•°è°ƒç”¨ã€æ•°ç»„èµ‹å€¼çš„è§£æåŒ–**

---

### **ç¬¬äºŒé˜¶æ®µï¼šå¸ƒå°”è¡¨è¾¾å¼ä¸æ§åˆ¶è¯­å¥**

å¢å¼ºå¸ƒå°”æ¡ä»¶åˆ¤æ–­ä¸è·³è½¬æ”¯æŒï¼š

| æ§åˆ¶ç»“æ„                  | çŠ¶æ€    | ä¸‹ä¸€æ­¥å»ºè®®            |
| --------------------- | ----- | ---------------- |
| `S â†’ if (B) S`        | âœ…ç®€åŒ–æ”¯æŒ | ğŸ” æ”¯æŒå¸ƒå°”è¡¨è¾¾å¼å’Œä»»æ„è¯­å¥å— |
| `S â†’ if (B) S else S` | âœ…ç®€åŒ–æ”¯æŒ | ğŸ” æ”¯æŒåµŒå¥—è¯­å¥ä¸é€šç”¨è§£æ   |
| `S â†’ while (B) S`     | âœ…ç®€åŒ–æ”¯æŒ | ğŸ” ä½¿ç”¨å¸ƒå°”è¡¨è¾¾å¼è§£æåˆ¤æ–­æ¡ä»¶ |

> å»ºè®®ç¬¬äºŒé˜¶æ®µå¢å¼ºï¼š**å¸ƒå°”è¡¨è¾¾å¼è®¡ç®—ã€é€šç”¨ label è·³è½¬ä¸æ§åˆ¶ç»“æ„ AST è¡¨è¾¾**

---

### **ç¬¬ä¸‰é˜¶æ®µï¼šå®Œæ•´è§£æå™¨è®¾è®¡**

åŸºäºè¯­æ³•æ ‘æˆ– SLR(1) è¿›è¡Œç»Ÿä¸€è¡¨è¾¾å¼ä¸è¯­å¥å—åˆ†æï¼š

* å¼•å…¥ AST èŠ‚ç‚¹å®šä¹‰ï¼ˆè¡¨è¾¾å¼ / è¯­å¥ç­‰ï¼‰
* ä½¿ç”¨é€’å½’ä¸‹é™æˆ–è‡ªå®šä¹‰è¯­æ³•åˆ†æå™¨æ„å»º AST
* ä½¿ç”¨ visitor æ¨¡å¼æˆ– `GenerateCode()` æ–¹æ³•ç”Ÿæˆ TAC

---

## ğŸ“Œ å»ºè®®ä¾æ¬¡å®Œæˆå†…å®¹ï¼ˆé˜¶æ®µä¸€ï¼‰

1. âœ… `S â†’ d = E`ï¼šå®ç°å˜é‡èµ‹å€¼ä¸ä»»æ„å³å€¼è¡¨è¾¾å¼è§£æ
2. âœ… `S â†’ return E`ï¼šåŸºäº `E` çš„å€¼ç”Ÿæˆ `RETURN t`
3. âœ… `S â†’ d(Å˜)`ï¼šæ”¯æŒä¼ å‚ï¼ˆå€’åº PARï¼‰+ CALL
4. âœ… `S â†’ d[Äš] = E`ï¼šè§£ææ•°ç»„ä¸‹æ ‡è¡¨è¾¾å¼ï¼Œç”Ÿæˆä¸‹æ ‡åœ°å€ä¸èµ‹å€¼ä»£ç 

å¦‚æœä½ åŒæ„ï¼Œæˆ‘å°†ä»ç¬¬ä¸€ä¸ªå¼€å§‹ï¼š**å®ç°è¡¨è¾¾å¼è§£æå¹¶æ”¯æŒå˜é‡èµ‹å€¼è¯­å¥ç”Ÿæˆä¸‰åœ°å€ä»£ç  `d = E`**ã€‚

æ˜¯å¦ç»§ç»­ï¼Ÿæ˜¯å¦å…è®¸æˆ‘æ‹†åˆ†å‡º `expr.go` æ¨¡å—ç”¨äºè¡¨è¾¾å¼è§£æï¼Ÿ

å­æ–‡ä»¶å¤¹ï¼š./expr
æ–‡ä»¶ï¼š./expr/expr.go
å†…å®¹ï¼š
package expr

import (
	"fmt"
)

var tempCounter = 0

func newTemp() string {
	tempCounter++
	return fmt.Sprintf("t%d", tempCounter)
}

// ä»…æ”¯æŒå½¢å¦‚ d = a + b * c - d çš„è¡¨è¾¾å¼
func GenerateAssignExpr(tokens []string) []string {
	code := []string{}
	target := tokens[0]
	exprTokens := tokens[2 : len(tokens)-1] // å»é™¤ `d = ... ;`
	fmt.Println("[DEBUG] tokens:", tokens)
	fmt.Println("[DEBUG] target:", target)
	fmt.Println("[DEBUG] exprTokens:", exprTokens)

	// ç®€å•æ”¯æŒï¼šå·¦ç»“åˆã€æ— æ‹¬å·ã€+ - * /
	// e.g. a + b * c - d
	var stack []string
	for i := 0; i < len(exprTokens); i++ {
		tok := exprTokens[i]

		if tok == "+" || tok == "-" || tok == "*" || tok == "/" {
			if len(stack) < 1 || i+1 >= len(exprTokens) {
				panic("Invalid expression")
			}
			left := stack[len(stack)-1]
			right := exprTokens[i+1]
			i++

			t := newTemp()
			code = append(code, fmt.Sprintf("%s = %s %s %s", t, left, tok, right))
			stack[len(stack)-1] = t // æ›¿æ¢ä¸ºæ–°ç»“æœ
		} else {
			stack = append(stack, tok)
		}
	}

	// æœ€ç»ˆèµ‹å€¼
	code = append(code, fmt.Sprintf("%s = %s", target, stack[0]))
	return code
}

å­æ–‡ä»¶å¤¹ï¼š./generator
æ–‡ä»¶ï¼š./generator/tac.go
å†…å®¹ï¼š
// generator/tac.go
package generator

import "fmt"

var tempCounter = 0
var labelCounter = 0

func newTemp() string {
	tempCounter++
	return fmt.Sprintf("t%d", tempCounter)
}

func newLabel() string {
	labelCounter++
	return fmt.Sprintf("L%d", labelCounter)
}

func GenerateExampleArrayAssignment() []string {
	code := []string{}
	t1 := newTemp()
	code = append(code, fmt.Sprintf("%s = i + 1", t1))
	t2 := newTemp()
	code = append(code, fmt.Sprintf("%s = j * 2", t2))
	t3 := newTemp()
	code = append(code, fmt.Sprintf("%s = 4", t3))
	t4 := newTemp()
	code = append(code, fmt.Sprintf("%s = %s * 5", t4, t1))
	t5 := newTemp()
	code = append(code, fmt.Sprintf("%s = %s + %s", t5, t4, t2))
	t6 := newTemp()
	code = append(code, fmt.Sprintf("%s = %s * 20", t6, t5))
	t7 := newTemp()
	code = append(code, fmt.Sprintf("%s = %s + %s", t7, t6, t3))
	t8 := newTemp()
	code = append(code, fmt.Sprintf("%s = %s * 4", t8, t7))
	t9 := newTemp()
	code = append(code, fmt.Sprintf("%s = 66", t9))
	code = append(code, fmt.Sprintf("a[%s] = %s", t8, t9))
	return code
}

func GenerateIfStatement() []string {
	code := []string{}
	t1 := newTemp()
	code = append(code, fmt.Sprintf("%s = 1", t1))
	l1 := newLabel()
	l2 := newLabel()
	code = append(code, fmt.Sprintf("IF x < %s THEN %s ELSE %s", t1, l1, l2))
	code = append(code, fmt.Sprintf("LABEL %s", l1))
	code = append(code, "y = 1")
	code = append(code, fmt.Sprintf("GOTO %s", newLabel()))
	code = append(code, fmt.Sprintf("LABEL %s", l2))
	code = append(code, "y = k")
	return code
}

func GenerateWhileStatement() []string {
	code := []string{}
	entry := newLabel()
	trueLabel := newLabel()
	falseLabel := newLabel()
	code = append(code, fmt.Sprintf("LABEL %s", entry))
	code = append(code, fmt.Sprintf("IF z != 0 THEN %s ELSE %s", trueLabel, falseLabel))
	code = append(code, fmt.Sprintf("LABEL %s", trueLabel))
	code = append(code, "x = 1")
	code = append(code, "y = b")
	code = append(code, fmt.Sprintf("GOTO %s", entry))
	code = append(code, fmt.Sprintf("LABEL %s", falseLabel))
	return code
}

æ–‡ä»¶ï¼š./go.mod
å†…å®¹ï¼š
module project

go 1.23.2

æ–‡ä»¶ï¼š./input.txt
å†…å®¹ï¼š
return a + b * c;

å­æ–‡ä»¶å¤¹ï¼š./lexer
æ–‡ä»¶ï¼š./lexer/lexer.go
å†…å®¹ï¼š
// lexer/lexer.go
package lexer

import (
	"strings"
	"unicode"
)

func Tokenize(input string) []string {
	var tokens []string
	current := ""
	for _, r := range input {
		if unicode.IsSpace(r) {
			if current != "" {
				tokens = append(tokens, current)
				current = ""
			}
		} else if strings.ContainsRune("[],;+*-=/()", r) {
			if current != "" {
				tokens = append(tokens, current)
				current = ""
			}
			tokens = append(tokens, string(r))
		} else {
			current += string(r)
		}
	}
	if current != "" {
		tokens = append(tokens, current)
	}
	return tokens
}
æ–‡ä»¶ï¼š./main.go
å†…å®¹ï¼š
// main.go
package main

import (
	"fmt"
	"os"
	"project/lexer"
	"project/parser"
)

func main() {
	input, err := os.ReadFile("input.txt")
	if err != nil {
		panic(err)
	}

	tokens := lexer.Tokenize(string(input))
	tac := parser.ParseAndGenerateTAC(tokens)

	for _, line := range tac {
		fmt.Println(line)
	}
}

æ–‡ä»¶ï¼š./output.txt
å†…å®¹ï¼š

å­æ–‡ä»¶å¤¹ï¼š./parser
æ–‡ä»¶ï¼š./parser/parser.go
å†…å®¹ï¼š
// parser/parser.go
package parser

import (
	"project/expr"
	"project/generator"
	"project/stmt" // æ–°å¢
)

func ParseAndGenerateTAC(tokens []string) []string {
	if len(tokens) > 0 && tokens[0] == "if" {
		return generator.GenerateIfStatement()
	} else if len(tokens) > 0 && tokens[0] == "while" {
		return generator.GenerateWhileStatement()
	} else if len(tokens) > 0 && tokens[0] == "return" {
		return stmt.GenerateReturn(tokens)
	} else if len(tokens) >= 3 && tokens[1] == "=" {
		return expr.GenerateAssignExpr(tokens)
	} else {
		return generator.GenerateExampleArrayAssignment()
	}
}



å­æ–‡ä»¶å¤¹ï¼š./stmt
æ–‡ä»¶ï¼š./stmt/return.go
å†…å®¹ï¼š
package stmt

import (
	"fmt"
	"project/expr"
)

func GenerateReturn(tokens []string) []string {
	// åŸå§‹ tokens: ["return", "a", "+", "b", "*", "c", ";"]
	exprTokens := tokens[1 : len(tokens)-1] // æˆªå–è¡¨è¾¾å¼éƒ¨åˆ†
	if len(exprTokens) == 0 {
		panic("Empty return expression")
	}

	// æ„é€ å‡çš„èµ‹å€¼ï¼š__return__ = expr
	fakeAssign := append([]string{"__return__", "="}, exprTokens...)
	fmt.Println("[DEBUG] fakeAssign:", fakeAssign) // âœ… debug è¾“å‡ºç¡®è®¤
	code := expr.GenerateAssignExpr(fakeAssign)

	// å–å‡ºæœ€åä¸€è¡Œè·å– return çš„ä¸´æ—¶å˜é‡å
	last := code[len(code)-1]
	retVar := last[len("__return__ = "):]
	code = code[:len(code)-1]
	code = append(code, fmt.Sprintf("RETURN %s", retVar))
	return code
}

